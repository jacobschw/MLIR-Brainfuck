// RUN: Bf-opt %s --optbf-to-explicitbf > %t
// RUN: FileCheck %s < %t

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL:   bf_pointer.ptr @bf_ptr = 0 : () -> ()
// CHECK:         memref.global "private" @bf_memory : memref<30000xi8>
// CHECK:         func.func private @getchar() -> i32
// CHECK:         func.func private @putchar(i32) -> i32

// CHECK-LABEL:   func.func @main() {
// CHECK:           %[[VAL_0:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:           %[[VAL_1:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:           %[[VAL_2:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_1]]] : memref<30000xi8>
// CHECK:           %[[VAL_3:.*]] = arith.constant 1 : i8
// CHECK:           %[[VAL_4:.*]] = arith.addi %[[VAL_2]], %[[VAL_3]] : i8
// CHECK:           memref.store %[[VAL_4]], %[[VAL_0]]{{\[}}%[[VAL_1]]] : memref<30000xi8>
// CHECK:           scf.while : () -> () {
// CHECK:             %[[VAL_5:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:             %[[VAL_6:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:             %[[VAL_7:.*]] = memref.load %[[VAL_5]]{{\[}}%[[VAL_6]]] : memref<30000xi8>
// CHECK:             %[[VAL_8:.*]] = arith.constant 0 : i8
// CHECK:             %[[VAL_9:.*]] = arith.cmpi ne, %[[VAL_7]], %[[VAL_8]] : i8
// CHECK:             scf.condition(%[[VAL_9]])
// CHECK:           } do {
// CHECK:             %[[VAL_10:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:             %[[VAL_11:.*]] = index.constant 1
// CHECK:             %[[VAL_12:.*]] = index.add %[[VAL_10]], %[[VAL_11]]
// CHECK:             bf_pointer.write_ptr %[[VAL_12]] {name = @bf_ptr} : (index) -> ()
// CHECK:             %[[VAL_13:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:             %[[VAL_14:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:             %[[VAL_15:.*]] = memref.load %[[VAL_13]]{{\[}}%[[VAL_14]]] : memref<30000xi8>
// CHECK:             %[[VAL_16:.*]] = arith.constant 1 : i8
// CHECK:             %[[VAL_17:.*]] = arith.addi %[[VAL_15]], %[[VAL_16]] : i8
// CHECK:             memref.store %[[VAL_17]], %[[VAL_13]]{{\[}}%[[VAL_14]]] : memref<30000xi8>
// CHECK:             scf.while : () -> () {
// CHECK:               %[[VAL_18:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:               %[[VAL_19:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:               %[[VAL_20:.*]] = memref.load %[[VAL_18]]{{\[}}%[[VAL_19]]] : memref<30000xi8>
// CHECK:               %[[VAL_21:.*]] = arith.constant 0 : i8
// CHECK:               %[[VAL_22:.*]] = arith.cmpi ne, %[[VAL_20]], %[[VAL_21]] : i8
// CHECK:               scf.condition(%[[VAL_22]])
// CHECK:             } do {
// CHECK:               %[[VAL_23:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:               %[[VAL_24:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:               %[[VAL_25:.*]] = memref.load %[[VAL_23]]{{\[}}%[[VAL_24]]] : memref<30000xi8>
// CHECK:               %[[VAL_26:.*]] = arith.constant 1 : i8
// CHECK:               %[[VAL_27:.*]] = arith.addi %[[VAL_25]], %[[VAL_26]] : i8
// CHECK:               memref.store %[[VAL_27]], %[[VAL_23]]{{\[}}%[[VAL_24]]] : memref<30000xi8>
// CHECK:               scf.yield
// CHECK:             }
// CHECK:             %[[VAL_28:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:             %[[VAL_29:.*]] = index.constant 1
// CHECK:             %[[VAL_30:.*]] = index.sub %[[VAL_28]], %[[VAL_29]]
// CHECK:             bf_pointer.write_ptr %[[VAL_30]] {name = @bf_ptr} : (index) -> ()
// CHECK:             %[[VAL_31:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:             %[[VAL_32:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:             %[[VAL_33:.*]] = memref.load %[[VAL_31]]{{\[}}%[[VAL_32]]] : memref<30000xi8>
// CHECK:             %[[VAL_34:.*]] = arith.constant -1 : i8
// CHECK:             %[[VAL_35:.*]] = arith.addi %[[VAL_33]], %[[VAL_34]] : i8
// CHECK:             memref.store %[[VAL_35]], %[[VAL_31]]{{\[}}%[[VAL_32]]] : memref<30000xi8>
// CHECK:             scf.yield
// CHECK:           }
// CHECK:           %[[VAL_36:.*]] = call @getchar() : () -> i32
// CHECK:           %[[VAL_37:.*]] = llvm.trunc %[[VAL_36]] : i32 to i8
// CHECK:           %[[VAL_38:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:           %[[VAL_39:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:           memref.store %[[VAL_37]], %[[VAL_38]]{{\[}}%[[VAL_39]]] : memref<30000xi8>
// CHECK:           %[[VAL_40:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:           %[[VAL_41:.*]] = bf_pointer.read_ptr {name = @bf_ptr} : () -> index
// CHECK:           %[[VAL_42:.*]] = memref.load %[[VAL_40]]{{\[}}%[[VAL_41]]] : memref<30000xi8>
// CHECK:           %[[VAL_43:.*]] = llvm.sext %[[VAL_42]] : i8 to i32
// CHECK:           %[[VAL_44:.*]] = call @putchar(%[[VAL_43]]) : (i32) -> i32
// CHECK:           %[[VAL_45:.*]] = memref.get_global @bf_memory : memref<30000xi8>
// CHECK:           memref.dealloc %[[VAL_45]] : memref<30000xi8>
// CHECK:           return
// CHECK:         }

Bf.module {
    bf_red.increment {amount = 1 : si8}

    Bf.loop {
        bf_red.shift {value = 1 : si32}
        bf_red.increment {amount = 1 : si8}

        Bf.loop {
            bf_red.increment {amount = 1 : si8}
        }

        bf_red.shift {value = -1 : si32}
        bf_red.increment {amount = -1 : si8}
    }

    Bf.input
    Bf.output
}